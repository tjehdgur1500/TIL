# TIL 2020-05-07

## 오늘 배운 내용

---

- Templates 를 만들어 기본적인 회원가입 폼을 작성했다.

- 장고에서 url 연결이 어떻게 이루어지는지 알아보았다.

```{.python}

myproject/urls.py 에서

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('yourapp/', include('yourapp.urls')),
]

```

admin url을 보면 admin 경로에 admin 페이지의 각종 urls 를 담고있다는 말인데
마찬가지로 내 template를 연결하려면 path 지정을 해주어야 한다.
경로명을 첫번째 인자로, 두번째는 include(포함시킬 app.urls) 로 urls를 지정해준다.

앱 안에 urls를 지정해준 적이 없기 때문에 urls.py를 하나 생성해서
path를 지정해줘야한다.

이번엔 templates를 화면에 보여주기 위해 앞으로 작성할 views 에서 로직함수를 가져온다. 이 로직함수는 templates을 urls로 전송해줄 것이다.

```{.python}

myapp/urls.py 에서

from django.urls import path
from . import views

urlpatterns = [
    path('app/', views.register, name="register"),
]

```

그럼 아래에서 볼 templates 를 가져올 로직을 연결할 준비가 된것이다.

- views 에서 로직처리를 하는 메서드를 생성하였다.

- 기본적으로 HttpRequest로 요청하는데 장고의 shortcuts 모듈에 render 기능이
  있다.

- 장고에서는 로직을 생성하는데 request(요청)을 받아 render 함수를 호출하고
  render 함수는 요청과 함께 template을 반환한다.
  이때 template을 화면에 띄워주는데 지정한 경로의 URL로 연결되있기 때문에
  클라이언트의 화면에 렌더링 되는것이다.

```{.python}
from django.shortcuts import render

  def register(request) :
    return render(request, 'register.html')

```

python manage.py runserver 로 서버를 실행시켜 확인해보면 templates가
정상적으로 렌더링 되는걸 볼 수 있을것이다.

이제 실제 서버로 데이터를 넘겨주는 로직을 구성해야한다.
이 templates는 회원가입 form 으로 작성되어있다.
그러므로 서버로 데이터를 보내기 위해 POST 방식으로 되어있다.

하지만 GET 방식을도 접속이 가능하다.

- GET : 실제 주소로 입력해서 접속함 ex) github.com/tjehdgur1500/TIL
        key-value 한쌍으로 이루어져 있음
        URL 형태라 다른사람도 접속 할 수 있음
        데이터를 보내는 양에 한계가 있음

- POST : form 에서 입력값을 서버에 데이터 전송을 한다.
         URL에 데이터를 붙이지 않고 body에다 데이터를 넣어서 보낸다.

```{.python}

from django.shortcuts import render
from django.contrib.auth.hashers import make_password
from .models import Fcuser

  def register(request) :

    if request.method == 'GET' :
      return render(request, 'register.html')
    elif request.method == 'POST' :
      username = request.POST.get('username', None)
      password = request.POST.get('password', None)
      re_password = request.POST.get('re-password', None)

     res_data = {}
     if not (username and password and re_password and useremail):
          res_data['error'] = "모든 값을 입력하지 않았습니다."
     elif password != re_password:
          res_data['error'] = "비밀번호가 일치하지 않습니다."
     else:
          fcuser = Fcuser(

              username=username,
              useremail=useremail,
              password=make_password(password)
          )

          fcuser.save()

    return render(request, 'register.html', res_data)

```

로직을 흐름대로 처리해보자면
우선 GET 방식일때는 입력폼을 렌더링 할것이다.

혹 POST 방식일때는 get() 함수로 form의 name key 값을 얻어온다.
얻어온 값을 새 변수에 할당한다.

```{.python}
request.POST.get('username', None)
```

default 값이 None 인데 None 은 말그대로 False로 값이 없다는 말이다.
입력을 안했을때 라고 해석하면 될 것 같다.

res_data = {} 라는 빈 dict 를 만든다. 만든 이유는 사용자가
입력을 잘 못 했을 경우 예외처리를 해주기 위함이다.

if not 조건문으로 키값을 받아온 변수들을 and 조건을 건다.
이렇게 되면 어떤 값중 하나라도 None 일 경우

res_data['error'] = '모든 값을 입력하지 않았습니다.'
라고 error 키와 value를 생성해 에러메시지로 예외처리를 하는것이다.

같은 방식으로

```{.python}

elif password != re_password:

  res_data['error'] = "비밀번호가 일치하지 않습니다."

```

이렇게 예외 처리를 하면 이 조건을 만족 했을때
렌더링되는 화면에 이 에러 메시지와 입력폼이 같이 출력 된다.

```{.python}

     else:
          fcuser = Fcuser(

              username=username,
              useremail=useremail,
              password=make_password(password)
          )

          fcuser.save()

    return render(request, 'register.html', res_data)

```

만약 검증을 성공 했다면 이전에 만든 Models의 Fcuser 클래스를 불러와
해당 클래스의 필드에 변수를 할당한다.

그리고나서 이 클래스(필드)를 저장한다.

이렇게 하면 실제 DB의 필드에 값들이 저장 된것이다.

error가 발생하지 않았으므로 request, 'register.html' 이
URL로 연결되어 전달 된다.

---

잠깐 register.html 같은 tempaltes에서 필수로 들어가야할 템플릿 태그가 있다.
{% csrf_token %} 이라는 크로스 사이트 요청 위조 방지 토큰인데



다른 브라우저에서 이 데이터를 접속하려할때 암호화 시켜 이 token이 없다면
접속을 제한하는 방법이다.

장고에서 이 token이 없으면 오류가 나니 꼭 넣어야한다.

{{ 'error' }} view에서 넘어온 객체인것이다.
그럼 error 발생시 메시지를 할당했으니 실제 html에는 메시지를 출력한다.

**{% %} 템플릿 태그 **
** {{}} 템플릿 변수 **
