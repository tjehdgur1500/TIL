# TIL 2021-03-25


재귀란 동일한 문제를 해결할때 더 작은경우를 해결하는것을 말한다.

즉 문제를 해결시에는 쪼개서 생각하기를 말하는것이다.

더 추상적인 개념으로는 어떤 함수가 스스로를 호출하는것을 말함

```jsx
let sum = [1,2,3,4,5]

function arrSum(sum){
    let result = 0;
   for (let i=0; i < sum.length;i++){
      result += sum[i]
   }
    return result
}

arrSum(sum)

```

자연수를 모두 더하는 알고리즘인데 , 이문제를 재귀로 풀어본다면,

1. 원래의 문제에서 출발하여 더 작은 경우를 생각하기

```jsx
arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]);
```

10 , 3, 6, 2 는 어려우니 3,6 ,2 접근

 2. 계속해서 문제가 더는 작아지지 않을 때까지 더 작은 경우를 생각하기

```jsx
arrSum([3, 6, 2]) = 3 + arrSum([6, 2]);
arrSum([6, 2]) = 6 + arrSum([2]);
arrSum([2]) = 2 + arrSum([]);
```

 3. 이렇게 문제 풀기를 미루다가, 

     문제가 간단해져서 바로 풀 수 있게 되는 순간에 미뤄왔던 문제들을 차근차근 해결

```jsx
arrSum([]) = 0; // <-- 문제가 더는 작아지지 않는 순간
// 가장 작은 경우의 해결책을 적용한다.
arrSum([2]) = 2 + arrSum([]) = 2;
arrSum([6, 2]) = 6 + arrSum([2]) = 6 + 2 = 8;
arrSum([3, 6, 2]) = 3 + arrSum([6, 2]) = 3 + 8 = 11;
arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]) = 10 + 11 = 21;
```

`arrSum`을 아래와 같이 보다 엄밀하게(formally) 정의할 수 있다.

```jsx
arrSum(arr)
1. arr이 빈 배열인 경우 = 0
2. 그 외의 경우 = arr[0] + arrSum(arr2)
   (arr2는 arr의 첫 요소를 제외한 나머지 배열)
```

arrSum은 (인자가 빈 배열이 아닌 경우) 실행과정 중에 자기 자신을 호출하기도 한다.

이러한 호출 방식을 재귀 호출이라고 한다.

## 재귀적으로 사고하기

### 문제를 쪼개고 경우의 수를 나누기

어떤 기준을 정하고 그 기준에 따라 문제를 더 큰 경우와 작은 경우로 구분할 수 있는 지를 생각한다.
일반적으로 입력값이 이 기준을 정하는 대상된다.
이 때 중요한 관점은 **순서와 크기** 인데  
주어진 입력값 또는 문제 상황을 크기를 기준으로 구분할 수 있거나, 
순서를 명확하게 정할 수 있는지를 살펴본다.

- `arrSum`의 경우 입력값인 배열을 크기에 따라 구분할 수 있다. 

일반적으로 문제를 더 이상 쪼갤 수 없는 경우와 그렇지 않은 경우로 나눕니다.

- `arrSum`은 입력값이 빈 배열인 경우와 그렇지 않은 경우로 나눌 수 있다.

- `arrSum: [number] => number`
- `arrSum([ ])`
- `arrSum([e1, e2, ... , en])`

### **단순한 문제 해결하기**

문제를 여러 경우로 구분한 다음에는 쉬운 문제부터 해결하는데 ,
이를 재귀의 기초(base case)이라고 부른다.
이 base case 는 재귀의 탈출 조건을 만들어준다고 볼 수 있다.

- `arrSum`를 더 이상 쪼갤 수 없는 경우는 입력값이 빈 배열일 경우이고, 이 때 arrSum은 0이다.
- `arrSum: [number] => number`
- `arrSum([ ]) = 0`
- `arrSum([e1, e2, ... , en])`

### 복잡한 문제 해결하기

- `arrSum`이 길이가 1 이상인 배열을 입력으로 받을 경우, 맨 앞의 요소를 따로 구하고(배열의 맨 앞의 요소이기 때문에 `head`라고 이름을 붙임), 나머지 요소를 새로운 입력값으로 갖는 문제를 해결하여 얻은 결과를 `head`에 더한다.
- `arrSum: [number] => number`
- `arrSum([ ]) = 0`
- `arrSum([e1, e2, ... , en]) = e1 + arrSum([e2, ..., en])`
- 배열이 있을 때 `head`와 나머지 부분(`tail`)을 구분하면 해결하기 수월해진다.

### 코드 구현

```jsx
function arrSum(arr) {
// 재귀의 기초 (base case)
// 문제를 더 이상 쪼갤 수 없을 경우
if (arr의 길이가 0인 경우) {
    return 0;
}
// recursive Case
// 그렇지 않은 경우
// head: 배열의 첫 요소
// tail: 배열의 첫 요소만 제거된 배열
return head + arrSum(tail);
}
```
문제를 작은단위로 나눠서 봤을때 이런식으로 문제를 직접 써가면서 해결해나가도 좋다.
```js
arrSUM([1,2,3,4])

1 , [2, 3, 4] return 1 + 9
2 , [3, 4] return 2 + 7
3 , [4]  return 3 + 4
4 , []	return 4 + 0
[]  return 0

```